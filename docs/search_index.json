[["index.html", "Practical R: a concise manual Preface", " Practical R: a concise manual Lingyun Zhang 2022-01-06 Preface To be written. "],["ti.html", "1 Tidyverse way 1.1 tibble 1.2 Creating a tibble 1.3 Selecting columns 1.4 Creating new column 1.5 Keeping some rows 1.6 Arrange rows 1.7 Changing variables' names 1.8 Re-arranging variables' positions 1.9 Making summary/aggregation 1.10 On group_by() 1.11 Convert wide to long table 1.12 Convert long to wide table", " 1 Tidyverse way In this chapter (Chapter 1) and the next one, we deal with data frames, and we cover how to create a data frame; how to select from the data frame the columns that we want; how to create a new column based on existed columns in the data frame; how to keep the rows that meet our set conditions; how to arrange the data frame based on some variables; how to change variables' names; how to re-arrange positions of variables in the data frame; how to have summary of the data frame; how to convert a long table to a wide table; how to convert a wide table to a long table; The difference between Chapter 1 and Chapter 2 is that for the same task we use different tools (to be exact functions)---in this chapter we use functions that come from tidyverse package (to be exact, it's a collection of R packages, including readr, tibble, dplyr, tidyr, ggplot2, purrr, stringr and forcats as components), whereas in the next chapter we use functions that mainly belong to data.table package. The first line of R codes in this chapter should be library(tidyverse) 1.1 tibble What is a tibble? The short answer is: A tibble is a data frame---probably this is enough, but we may also want to know that---it's an enhanced data frame in a sense that it forces some rules (e.g. type rule) to be more strictly obeyed (the effects are: on one hand side, we lose some freedom associated with a data frame, on the other hand side, it prevents us from making some subtle mistakes while dealing with a data frame.) Tidyverse community encourages people to use tibbles. A tibble may not be working with some (old) packages, in that case, just use as.data.frame() to do converting. We can convert a data frame to a tibble by using tibble::as_tibble(). 1.2 Creating a tibble We can use data.frame() to create a data frame; one important thing is that we should almost always set stringsAsFactors = FALSE. To create a tibble, we use tibble::tibble() Example 1: a_df &lt;- data.frame(x = c(1L:3L, NA, NA), y = rnorm(5), z = c(NA, &#39;a&#39;, NA, &#39;b&#39;, &#39;c&#39;), stringsAsFactors = FALSE) (a_df) ## x y z ## 1 1 -0.52214968 &lt;NA&gt; ## 2 2 0.30807406 a ## 3 3 0.24518971 &lt;NA&gt; ## 4 NA 0.07797894 b ## 5 NA -1.35518388 c Example 2: library(tidyverse) a_tibble &lt;- tibble(x = c(1L:3L, NA, NA), y = rnorm(5), z = c(NA, &#39;a&#39;, NA, &#39;b&#39;, &#39;c&#39;)) (a_tibble) ## # A tibble: 5 x 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 -0.182 &lt;NA&gt; ## 2 2 0.945 a ## 3 3 -1.96 &lt;NA&gt; ## 4 NA -0.0942 b ## 5 NA 0.374 c Example 3: tibble is more &quot;strict&quot; We can run the following code if we want but it silently changes the type of variable x from integer to character. a_df[is.na(a_df)] &lt;- &quot;&quot; If we run the following code we get an error message a_tibble[is.na(a_tibble)] &lt;- &quot;&quot; Error message 1.3 Selecting columns We can use functions select() (plus all_of()) and select_at(). Example 1: b_df &lt;- select(a_df, x, y) (b_df) ## x y ## 1 1 -0.52214968 ## 2 2 0.30807406 ## 3 3 0.24518971 ## 4 NA 0.07797894 ## 5 NA -1.35518388 (c(is_tibble(a_df), is_tibble(b_df), is.data.frame(b_df))) ## [1] FALSE FALSE TRUE c_df &lt;- select_at(a_df, .var = c(&quot;z&quot;, &quot;y&quot;)) (c_df) ## z y ## 1 &lt;NA&gt; -0.52214968 ## 2 a 0.30807406 ## 3 &lt;NA&gt; 0.24518971 ## 4 b 0.07797894 ## 5 c -1.35518388 c1_df &lt;- select(a_df, all_of(c(&quot;z&quot;, &quot;y&quot;))) (identical(c_df, c1_df)) ## [1] TRUE Example 2: Selecting plus renaming d_df &lt;- select(a_df, new_x = x, new_y = y) (d_df) ## new_x new_y ## 1 1 -0.52214968 ## 2 2 0.30807406 ## 3 3 0.24518971 ## 4 NA 0.07797894 ## 5 NA -1.35518388 1.4 Creating new column We use function mutate() Example 1: e_df &lt;- mutate(a_df, u = y^2, v = is.na(z)) (e_df) ## x y z u v ## 1 1 -0.52214968 &lt;NA&gt; 0.272640293 TRUE ## 2 2 0.30807406 a 0.094909627 FALSE ## 3 3 0.24518971 &lt;NA&gt; 0.060117995 TRUE ## 4 NA 0.07797894 b 0.006080715 FALSE ## 5 NA -1.35518388 c 1.836523349 FALSE 1.5 Keeping some rows For keeping the rows that meet certain conditions, we use filter(). Example: f_df &lt;- filter(a_df, abs(y) &gt; 0.5 &amp; !is.na(z)) (f_df) ## x y z ## 1 NA -1.355184 c If we want to choose rows using their position, the useful functions are: slice(n1:n2), slice_head(n = n1), slice_tail(n = n2), slice_sample(n = n1) (or slice_sample(prop = 0.x)) Example: fa_df &lt;- slice_sample(a_df, prop = 0.4) (fa_df) ## x y z ## 1 NA 0.07797894 b ## 2 1 -0.52214968 &lt;NA&gt; Another two useful slice-functions: slice_min() and slice_max(). Example: fb_df &lt;- slice_min(a_df, y, n = 2) (fb_df) ## x y z ## 1 NA -1.3551839 c ## 2 1 -0.5221497 &lt;NA&gt; fc_df &lt;- slice_max(a_df, y, n = 2) (fc_df) ## x y z ## 1 2 0.3080741 a ## 2 3 0.2451897 &lt;NA&gt; 1.6 Arrange rows Some rows of the data frame will be put at the top and other rows will be put at the bottom; for this purpose, we use arrange(). Example: g_df &lt;- arrange(a_df, desc(z)) (g_df) ## x y z ## 1 NA -1.35518388 c ## 2 NA 0.07797894 b ## 3 2 0.30807406 a ## 4 1 -0.52214968 &lt;NA&gt; ## 5 3 0.24518971 &lt;NA&gt; h_df &lt;- arrange(a_df, desc(z), y) (h_df) ## x y z ## 1 NA -1.35518388 c ## 2 NA 0.07797894 b ## 3 2 0.30807406 a ## 4 1 -0.52214968 &lt;NA&gt; ## 5 3 0.24518971 &lt;NA&gt; 1.7 Changing variables' names We use rename(). Example: i_df &lt;- rename(a_df, new_z = z) (i_df) ## x y new_z ## 1 1 -0.52214968 &lt;NA&gt; ## 2 2 0.30807406 a ## 3 3 0.24518971 &lt;NA&gt; ## 4 NA 0.07797894 b ## 5 NA -1.35518388 c 1.8 Re-arranging variables' positions For outputting purpose, we may want to re-arrange variables' positions, and we can use select(df, all_of(a_ch_vec)) or select_at(df, .var = a_ch_vec) or relocate(). Example: new_var_oder &lt;- c(&quot;z&quot;, &quot;y&quot;, &quot;x&quot;) j_df &lt;- select(a_df, all_of(new_var_oder)) (j_df) ## z y x ## 1 &lt;NA&gt; -0.52214968 1 ## 2 a 0.30807406 2 ## 3 &lt;NA&gt; 0.24518971 3 ## 4 b 0.07797894 NA ## 5 c -1.35518388 NA j_df_a &lt;- select_at(a_df, .var = new_var_oder) (j_df_a) ## z y x ## 1 &lt;NA&gt; -0.52214968 1 ## 2 a 0.30807406 2 ## 3 &lt;NA&gt; 0.24518971 3 ## 4 b 0.07797894 NA ## 5 c -1.35518388 NA j_df_b &lt;- relocate(a_df, c(z, y, x)) (j_df_b) ## z y x ## 1 &lt;NA&gt; -0.52214968 1 ## 2 a 0.30807406 2 ## 3 &lt;NA&gt; 0.24518971 3 ## 4 b 0.07797894 NA ## 5 c -1.35518388 NA 1.9 Making summary/aggregation We do some things like the following summ_df &lt;- a_df %&gt;% group_by(grp_var1, grp_var2) %&gt;% summarise(grp_total_of_v = sum(v), .groups = &quot;drop&quot;) and summ_df &lt;- a_df %&gt;% group_by(grp_var1, grp_var2) %&gt;% summarise(grp_count = n(), .groups = &quot;drop&quot;) Example 1: Making summary of one variable fake_data &lt;- data.frame(type = rep(letters[1:3], each = 3), x = 1:9, y = rnorm(9), z = runif(9)) a_summ &lt;- fake_data %&gt;% group_by(type) %&gt;% summarise(grouped_mean_of_x = mean(x), .groups = &quot;drop&quot;) (a_summ) ## # A tibble: 3 x 2 ## type grouped_mean_of_x ## &lt;fct&gt; &lt;dbl&gt; ## 1 a 2 ## 2 b 5 ## 3 c 8 Example 2: Making summary of many variables b_summ &lt;- fake_data %&gt;% group_by(type) %&gt;% summarise(across(c(x, y, z), mean, .names = &quot;grouped_mean_of_{.col}&quot;), .groups = &quot;drop&quot;) (b_summ) ## # A tibble: 3 x 4 ## type grouped_mean_of_x grouped_mean_of_y grouped_mean_of_z ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2 -0.419 0.317 ## 2 b 5 1.05 0.415 ## 3 c 8 0.0563 0.829 1.10 On group_by() Not only does group_by() work with summarise(), but it also works with other dplyr functions. Take notice the following points: group_by(grp_var) %&gt;% summarise(, .groups = 'drop'). The other arguments for .groups are NULL (the default), 'drop_last' and 'keep'. My habit is that always using .groups = 'drop', in such a way the output is an un-grouped data frame. If group_by() has been used before select(), then the grouping variables must appear in select(). If we don't want these grouping variables, we do ungroup() before select(). mutate() under group_by(): see Example 1 below. filter() under group_by: see Example 2 below. arrange() under group_by: see Example 3 below. Example 1: my_df &lt;- data.frame(g = rep(letters[1:3], each = 3), x = runif(9), y = LETTERS[1:9], stringsAsFactors = FALSE) (my_df) ## g x y ## 1 a 0.1238133 A ## 2 a 0.3352974 B ## 3 a 0.6002646 C ## 4 b 0.2019728 D ## 5 b 0.3108819 E ## 6 b 0.1935392 F ## 7 c 0.9607111 G ## 8 c 0.7452332 H ## 9 c 0.4071506 I my_df_a &lt;- my_df %&gt;% group_by(g) %&gt;% mutate(ID_in_grp = row_number()) %&gt;% ungroup() (my_df_a) ## # A tibble: 9 x 4 ## g x y ID_in_grp ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 a 0.124 A 1 ## 2 a 0.335 B 2 ## 3 a 0.600 C 3 ## 4 b 0.202 D 1 ## 5 b 0.311 E 2 ## 6 b 0.194 F 3 ## 7 c 0.961 G 1 ## 8 c 0.745 H 2 ## 9 c 0.407 I 3 Example 2: my_df_b &lt;- my_df_a %&gt;% group_by(g) %&gt;% filter(ID_in_grp == group_indices()) %&gt;% ungroup() (my_df_b) ## # A tibble: 3 x 4 ## g x y ID_in_grp ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; ## 1 a 0.124 A 1 ## 2 b 0.311 E 2 ## 3 c 0.407 I 3 Example 3: my_df_c &lt;- my_df %&gt;% group_by(g) %&gt;% arrange(x, .by_group = TRUE) # order first by g and then x (my_df_c) ## # A tibble: 9 x 3 ## # Groups: g [3] ## g x y ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 a 0.124 A ## 2 a 0.335 B ## 3 a 0.600 C ## 4 b 0.194 F ## 5 b 0.202 D ## 6 b 0.311 E ## 7 c 0.407 I ## 8 c 0.745 H ## 9 c 0.961 G 1.11 Convert wide to long table Example: a_wide_tbl &lt;- data.frame(ID = 1:5, math_score = sample(50:100, 5, replace = TRUE), stats_score = sample(50:100, 5, replace = TRUE), english_score = sample(50:100, 5, replace = TRUE)) (a_wide_tbl) ## ID math_score stats_score english_score ## 1 1 84 50 76 ## 2 2 61 94 74 ## 3 3 82 64 71 ## 4 4 73 55 50 ## 5 5 97 78 70 a_long_tbl &lt;- a_wide_tbl %&gt;% pivot_longer(cols = math_score:english_score, names_to = &quot;subject&quot;, values_to = &quot;score&quot;) %&gt;% # polish mutate(subject = stringr::str_sub(subject, start = 1L, end = -7L)) (a_long_tbl) ## # A tibble: 15 x 3 ## ID subject score ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 math 84 ## 2 1 stats 50 ## 3 1 english 76 ## 4 2 math 61 ## 5 2 stats 94 ## 6 2 english 74 ## 7 3 math 82 ## 8 3 stats 64 ## 9 3 english 71 ## 10 4 math 73 ## 11 4 stats 55 ## 12 4 english 50 ## 13 5 math 97 ## 14 5 stats 78 ## 15 5 english 70 1.12 Convert long to wide table b_wide_tbl &lt;- a_long_tbl %&gt;% pivot_wider(id_cols = ID, names_from = subject, values_from = score) %&gt;% # polish rename_with(.cols = math:english, .fn = function(x) stringr::str_c(x, &quot;_score&quot;)) (b_wide_tbl) ## # A tibble: 5 x 4 ## ID math_score stats_score english_score ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 84 50 76 ## 2 2 61 94 74 ## 3 3 82 64 71 ## 4 4 73 55 50 ## 5 5 97 78 70 "],["dt.html", "2 Data.table way 2.1 data.table 2.2 Creating a data.table 2.3 Selecting columns 2.4 Creating new column 2.5 Keeping some rows 2.6 Arrange rows 2.7 Changing variables' names 2.8 Re-arranging variables' positions 2.9 Making summary/aggregation", " 2 Data.table way The first line of R codes in this chapter should be library(data.table) What can be done with dplyr package (one component of tidyverse package; dplyr stands for &quot;data frame apply r&quot;) can also be done using data.table package, and vice versa. Lots of people like data.talbe package for many reasons, in particular fast speed of data.table codes. To me, if I need to deal with data set of one million or more rows, then I will switch from using dplyr to data.table package. 2.1 data.table What is a data.table? The answer is: It is an enhanced version of data frame. The meaning of &quot;enhanced&quot; is that it allows DT[i, j, by] that is, &quot;take DT, subset/reorder rows using i, then calculate j, grouped by by&quot; (see this and detailed explanations from https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html) 2.2 Creating a data.table We use data.table() to create a data.table. For converting from a data frame to a data.table, we use SetDT (especially for large data set) or as.data.table. Example: library(data.table) a_dt &lt;- data.table(ID = letters[1:5], x = 1:5, y = month.name[1:5]) (a_dt) ## ID x y ## 1: a 1 January ## 2: b 2 February ## 3: c 3 March ## 4: d 4 April ## 5: e 5 May 2.3 Selecting columns The syntax is: DT[, .(&lt;sel_var1 =&gt; var1, &lt;sel_var2 =&gt; var2)] where &lt;...&gt; means optional; or DT[, c(&quot;var1&quot;, &quot;var2&quot;)] or sel_cols &lt;- c(&quot;var1&quot;, &quot;var2&quot;) DT[, sel_cols, with = FALSE] Example: b_dt &lt;- a_dt[, .(new_y = y, new_x = x)] (b_dt) ## new_y new_x ## 1: January 1 ## 2: February 2 ## 3: March 3 ## 4: April 4 ## 5: May 5 vars_to_choose &lt;- c(&quot;ID&quot;, &quot;y&quot;) c_dt &lt;- a_dt[, vars_to_choose, with = FALSE] (c_dt) ## ID y ## 1: a January ## 2: b February ## 3: c March ## 4: d April ## 5: e May 2.4 Creating new column The syntax is new_DT &lt;- copy(DT) new_DT[, `:=`(new_var = func(existed_vars))] If we care about memory and are aware of all possible side effects on the original DT, we can do DT[, `:=`(new_var = func(existed_vars))] About &quot;side effects&quot; of :=, see https://cran.r-project.org/web/packages/data.table/vignettes/datatable-reference-semantics.html Example: (the_name &lt;- names(a_dt)) ## [1] &quot;ID&quot; &quot;x&quot; &quot;y&quot; new_dt &lt;- copy(a_dt) new_dt[, `:=`(u = x^2)] (new_dt) ## ID x y u ## 1: a 1 January 1 ## 2: b 2 February 4 ## 3: c 3 March 9 ## 4: d 4 April 16 ## 5: e 5 May 25 a_dt[, `:=`(u = x^2)] (a_dt) ## ID x y u ## 1: a 1 January 1 ## 2: b 2 February 4 ## 3: c 3 March 9 ## 4: d 4 April 16 ## 5: e 5 May 25 (the_name) # it&#39;s also updated! ## [1] &quot;ID&quot; &quot;x&quot; &quot;y&quot; &quot;u&quot; 2.5 Keeping some rows The syntax is new_DT &lt;- DT[var1 == sth &amp; var2 &gt; sth | vars != sth] Example: dt_new &lt;- a_dt[x%%2 == 0 | u == 9] (dt_new) ## ID x y u ## 1: b 2 February 4 ## 2: c 3 March 9 ## 3: d 4 April 16 2.6 Arrange rows The syntax is DT[order(var1, -var2)] Example: d_dt &lt;- a_dt[order(-ID)] (d_dt) ## ID x y u ## 1: e 5 May 25 ## 2: d 4 April 16 ## 3: c 3 March 9 ## 4: b 2 February 4 ## 5: a 1 January 1 2.7 Changing variables' names The syntax is setnames(DT, &quot;old_name&quot;, &quot;new_name&quot;) Example: setnames(a_dt, c(&quot;x&quot;, &quot;y&quot;), c(&quot;new_x&quot;, &quot;new_y&quot;)) (a_dt) ## ID new_x new_y u ## 1: a 1 January 1 ## 2: b 2 February 4 ## 3: c 3 March 9 ## 4: d 4 April 16 ## 5: e 5 May 25 2.8 Re-arranging variables' positions The syntax is setcolorder(DT, neworder = new_order) Example: setcolorder(a_dt, neworder = c(&quot;ID&quot;, &quot;u&quot;, &quot;new_y&quot;, &quot;new_x&quot;)) (a_dt) ## ID u new_y new_x ## 1: a 1 January 1 ## 2: b 4 February 2 ## 3: c 9 March 3 ## 4: d 16 April 4 ## 5: e 25 May 5 2.9 Making summary/aggregation The syntax: summ_dt &lt;- DT[, .(grp_total_of_v = sum(v)), by = .(grp_var1, grp_var2)] and for counting summ_dt &lt;- DT[, .(grp_count = .N), by = .(grp_var1, grp_var2)] and for summarizing many variables summ_dt &lt;- DT[, lapply(.DT, mean), by = .(grp_var1, grp_var2), .SDcols = c(&quot;var1&quot;, &quot;var2&quot;)] Example 1: Making summary of one variable fake_dt &lt;- data.table(type = rep(letters[1:3], each = 3), x = 1:9, y = rnorm(9), z = runif(9)) a_summ_dt &lt;- fake_dt[, .(grouped_mean_of_x = mean(x)), by = type] (a_summ_dt) ## type grouped_mean_of_x ## 1: a 2 ## 2: b 5 ## 3: c 8 b_summ_dt &lt;- fake_dt[, .(grouped_count = .N), by = type] (b_summ_dt) ## type grouped_count ## 1: a 3 ## 2: b 3 ## 3: c 3 Example 2: Making summary of many variables c_summ_dt &lt;- fake_dt[, lapply(.SD, mean), by = type, .SDcols = c(&#39;x&#39;, &#39;z&#39;)] (c_summ_dt) ## type x z ## 1: a 2 0.58276993 ## 2: b 5 0.55184916 ## 3: c 8 0.06482805 "],["base-r.html", "3 Base R", " 3 Base R "],["ggplot-gridexta-patchwork.html", "4 ggplot + gridExta + patchwork", " 4 ggplot + gridExta + patchwork "],["writing-functions.html", "5 Writing functions", " 5 Writing functions "],["apply-family-functions.html", "6 apply family functions", " 6 apply family functions For iterations (repeating work), base R provides apply family functions. In my opinion, the mostly useful ones are apply() (taking a matrix as input), lapply() (taking a list as input) and sapply() (taking a list as input, but may be handier in some situations). Example 1: Using apply() a_matrix &lt;- matrix(1:9, ncol = 3, byrow = TRUE) row_sums &lt;- apply(a_matrix, 1, sum) col_sums &lt;- apply(a_matrix, 2, sum) (list(&quot;row_sums&quot; = row_sums, &quot;col_sums&quot; = col_sums)) ## $row_sums ## [1] 6 15 24 ## ## $col_sums ## [1] 12 15 18 Example 2: Using lapply(): bootstrap confidence interval set.seed(31415) a_sample &lt;- rnorm(10) my_sampling &lt;- function() {b_sample &lt;- sample(a_sample, size = 10, replace = TRUE) mean(b_sample) } bootstrap_mean &lt;- unlist(lapply(1:1000, FUN = function(i) my_sampling())) # or # bootstrap_mean &lt;- # sapply(1:1000, # FUN = function(i) my_sampling()) lower_and_upper_limits &lt;- quantile(bootstrap_mean, probs = c(0.025, 0.975)) lower_and_upper_limits ## 2.5% 97.5% ## -0.6901385 0.8049399 "],["purrr-package.html", "7 purrr package", " 7 purrr package "],["multiple-core-apply.html", "8 multiple core apply", " 8 multiple core apply "],["for-loops.html", "9 for loops", " 9 for loops "],["stringr-package.html", "10 stringr package", " 10 stringr package "],["lubridate-package.html", "11 lubridate package", " 11 lubridate package "],["gt-package.html", "12 gt package", " 12 gt package "],["leaflet-package.html", "13 leaflet package", " 13 leaflet package "],["shiny-package.html", "14 shiny package", " 14 shiny package "],["knitr-package.html", "15 knitr package", " 15 knitr package "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
